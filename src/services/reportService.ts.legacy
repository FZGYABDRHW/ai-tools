// ============================================================================
// LEGACY REPORT SERVICE - COMMENTED OUT DURING EFFECT-TS MIGRATION
// ============================================================================
// This service has been replaced by the new Effect-TS implementation
// See: src/services/effects/ for the new implementation
// ============================================================================

/*
import { Report, CreateReportRequest, UpdateReportRequest } from '../types';
import { reportGenerationService } from './reportGenerationService';
import { reportCheckpointService } from './reportCheckpointService';

class ReportService {
    private readonly STORAGE_KEY = 'ai_tools_reports';
    private migrationCheckInProgress = false;
    private fileSystemReports: Report[] | null = null;

    private async saveReport(report: Report): Promise<void> {
        if ((window.electronAPI as any)?.fileSystem?.saveReport) {
            await (window.electronAPI as any).fileSystem.saveReport(report);
        }
    }

    private async saveReportToFileSystem(report: Report): Promise<boolean> {
        try {
            if ((window.electronAPI as any)?.fileSystem?.saveReport) {
                return await (window.electronAPI as any).fileSystem.saveReport(report);
            }
            return false;
        } catch (error) {
            console.error('Error saving report to file system:', error);
            return false;
        }
    }

    private async loadReport(id: string): Promise<Report | null> {
        if ((window.electronAPI as any)?.fileSystem?.getReport) {
            return await (window.electronAPI as any).fileSystem.getReport(id);
        }
        return null;
    }

    private getReportsFromStorage(): Report[] {
        try {
            const stored = localStorage.getItem(this.STORAGE_KEY);
            return stored ? JSON.parse(stored) : [];
        } catch (error) {
            console.error('Error reading reports from storage:', error);
            return [];
        }
    }

    private saveReportsToStorage(reports: Report[]): void {
        try {
            localStorage.setItem(this.STORAGE_KEY, JSON.stringify(reports));
        } catch (error) {
            console.error('Error saving reports to storage:', error);
        }
    }

    // Check if migration has been completed and sync reports if needed
    private async syncReportsFromFileSystem(): Promise<void> {
        if (this.migrationCheckInProgress) {
            console.log('Migration check already in progress, skipping...');
            return;
        }

        this.migrationCheckInProgress = true;
        console.log('Starting sync from file system...');

        try {
            // Check if migration has been completed
            console.log('Checking migration status...');
            const migrationCompleted = await (window.electronAPI as any)?.migration?.hasCompletedMigration();
            console.log('Migration completed:', migrationCompleted);

            if (migrationCompleted) {
                // Get reports from file system
                console.log('Getting reports from file system...');
                const fileSystemReports = await (window.electronAPI as any)?.fileSystem?.getAllReports();
                console.log('File system reports:', fileSystemReports);

                if (fileSystemReports && fileSystemReports.length > 0) {
                    // Always sync from file system when migration is completed
                    // This ensures we have the complete migrated data
                    this.saveReportsToStorage(fileSystemReports);
                    this.fileSystemReports = fileSystemReports;
                    console.log(`✅ Synced ${fileSystemReports.length} reports from file system to localStorage`);
                } else {
                    console.log('No reports found in file system');
                }
            } else {
                console.log('Migration not completed, skipping sync');
            }
        } catch (error) {
            console.error('❌ Error syncing reports from file system:', error);
        } finally {
            this.migrationCheckInProgress = false;
        }
    }

    getAllReports(): Report[] {
        const localReports = this.getReportsFromStorage();

        // If localStorage has reports, use them
        if (localReports.length > 0) {
            return localReports;
        }

        // If localStorage is empty, return empty array
        // The sync will happen in the background and populate localStorage
        // UI components should use getAllReportsAsync() for immediate sync
        return localReports;
    }

    // Synchronous method that waits for sync to complete
    async getAllReportsWithSync(): Promise<Report[]> {
        console.log('getAllReportsWithSync called');
        const localReports = this.getReportsFromStorage();
        console.log('Local reports count:', localReports.length);
        console.log('Local reports:', localReports.map(r => ({ id: r.id, name: r.name })));

        // Always check if we need to sync from file system
        console.log('Checking if sync is needed...');
        await this.syncReportsFromFileSystem();

        // Return the reports (either from localStorage or newly synced)
        const finalReports = this.getReportsFromStorage();
        console.log('Final reports count:', finalReports.length);
        console.log('Final reports:', finalReports.map(r => ({ id: r.id, name: r.name })));
        return finalReports;
    }

    getReportById(id: string): Report | null {
        const reports = this.getAllReports();
        return reports.find(report => report.id === id) || null;
    }

    // Async versions for new file system
    async getAllReportsAsync(): Promise<Report[]> {
        if ((window.electronAPI as any)?.fileSystem?.getAllReports) {
            return await (window.electronAPI as any).fileSystem.getAllReports();
        }
        return [];
    }

    async getReportByIdAsync(id: string): Promise<Report | null> {
        return await this.loadReport(id);
    }

    // Method to manually trigger sync from file system
    async forceSyncFromFileSystem(): Promise<boolean> {
        try {
            await this.syncReportsFromFileSystem();
            return true;
        } catch (error) {
            console.error('Failed to force sync from file system:', error);
            return false;
        }
    }

    // Method to check if reports are available (useful for UI)
    hasReports(): boolean {
        return this.getAllReports().length > 0;
    }

    async createReport(request: CreateReportRequest): Promise<Report> {
        // Validate input
        if (!request.name || request.name.trim() === '') {
            throw new Error('Report name is required');
        }

        const reports = this.getAllReports();

        // Check for duplicate names
        const existingReport = reports.find(report =>
            report.name.toLowerCase() === request.name.toLowerCase()
        );
        if (existingReport) {
            throw new Error('A report with this name already exists');
        }

        const newReport: Report = {
            id: this.generateId(),
            name: request.name.trim(),
            prompt: request.prompt || '',
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString()
        };

        // Save to file system first
        const fileSystemSaved = await this.saveReportToFileSystem(newReport);
        if (fileSystemSaved) {
            console.log(`✅ Created new report in file system: ${newReport.name} (ID: ${newReport.id})`);
        } else {
            console.warn(`⚠️ Failed to save report to file system, falling back to localStorage: ${newReport.name}`);
        }

        // Also save to localStorage for immediate UI updates
        reports.push(newReport);
        this.saveReportsToStorage(reports);

        console.log(`Created new report: ${newReport.name} (ID: ${newReport.id})`);
        return newReport;
    }

    async updateReport(id: string, updates: UpdateReportRequest): Promise<Report | null> {
        const reports = this.getReportsFromStorage();
        const index = reports.findIndex(report => report.id === id);

        if (index === -1) return null;

        const updatedReport = {
            ...reports[index],
            ...updates,
            updatedAt: new Date().toISOString()
        };

        // Save to file system first
        const fileSystemSaved = await this.saveReportToFileSystem(updatedReport);
        if (fileSystemSaved) {
            console.log(`✅ Updated report in file system: ${updatedReport.name} (ID: ${updatedReport.id})`);
        } else {
            console.warn(`⚠️ Failed to save updated report to file system, falling back to localStorage: ${updatedReport.name}`);
        }

        // Also save to localStorage for immediate UI updates
        reports[index] = updatedReport;
        this.saveReportsToStorage(reports);
        return updatedReport;
    }

    async deleteReport(id: string): Promise<boolean> {
        const reports = this.getReportsFromStorage();
        const filteredReports = reports.filter(report => report.id !== id);

        if (filteredReports.length === reports.length) {
            return false; // Report not found
        }

        // Delete from file system first
        try {
            if ((window.electronAPI as any)?.fileSystem?.deleteReport) {
                const fileSystemDeleted = await (window.electronAPI as any).fileSystem.deleteReport(id);
                if (fileSystemDeleted) {
                    console.log(`✅ Deleted report from file system: ${id}`);
                } else {
                    console.warn(`⚠️ Failed to delete report from file system: ${id}`);
                }
            }
        } catch (error) {
            console.error(`Error deleting report from file system: ${id}:`, error);
        }

        // Save the filtered reports (remove the report) to localStorage
        this.saveReportsToStorage(filteredReports);

        // Clean up all related data for this report
        try {
            // Stop any ongoing generation for this report
            reportGenerationService.stopGeneration(id);

            // Clear generation state
            reportGenerationService.clearGeneration(id);

            // Clear checkpoint data
            reportCheckpointService.clearCheckpoint(id);

            console.log(`Cleaned up all data for report ${id}`);
        } catch (error) {
            console.error(`Error cleaning up data for report ${id}:`, error);
        }

        return true;
    }

    async saveReportData(id: string, tableData: {
        columns: string[];
        results: Array<Record<string, unknown>>;
        csv: string;
    }, extractedParameters?: {
        parameters: {
            limit?: number;
            taskStatus?: 'new' | 'done' | 'canceled' | 'in-work' | 'on-moderation' | 'awaiting-approve' | 'on-payment' | 'in-queue';
            timeRangeFrom?: string;
            timeRangeTo?: string;
        };
        humanReadable: string[];
    }): Promise<Report | null> {
        const reports = this.getReportsFromStorage();
        const index = reports.findIndex(report => report.id === id);

        if (index === -1) return null;

        const updatedReport = {
            ...reports[index],
            tableData,
            extractedParameters,
            lastGeneratedAt: new Date().toISOString(),
            updatedAt: new Date().toISOString()
        };

        // Save to file system first
        const fileSystemSaved = await this.saveReportToFileSystem(updatedReport);
        if (fileSystemSaved) {
            console.log(`✅ Saved report data to file system: ${updatedReport.name} (ID: ${updatedReport.id})`);
        } else {
            console.warn(`⚠️ Failed to save report data to file system, falling back to localStorage: ${updatedReport.name}`);
        }

        // Also save to localStorage for immediate UI updates
        reports[index] = updatedReport;
        this.saveReportsToStorage(reports);
        return updatedReport;
    }

    async clearReportData(id: string): Promise<Report | null> {
        const reports = this.getReportsFromStorage();
        const index = reports.findIndex(report => report.id === id);

        if (index === -1) return null;

        // Remove tableData, extractedParameters, and lastGeneratedAt
        const { tableData, extractedParameters, lastGeneratedAt, ...reportWithoutData } = reports[index];

        const clearedReport = {
            ...reportWithoutData,
            updatedAt: new Date().toISOString()
        };

        // Save to file system first
        const fileSystemSaved = await this.saveReportToFileSystem(clearedReport);
        if (fileSystemSaved) {
            console.log(`✅ Cleared report data in file system: ${clearedReport.name} (ID: ${clearedReport.id})`);
        } else {
            console.warn(`⚠️ Failed to clear report data in file system, falling back to localStorage: ${clearedReport.name}`);
        }

        // Also save to localStorage for immediate UI updates
        reports[index] = clearedReport;
        this.saveReportsToStorage(reports);
        console.log(`Cleared table data and extracted parameters for report ${id}`);
        return clearedReport;
    }

    exportReports(): string {
        const reports = this.getAllReports();
        return JSON.stringify(reports, null, 2);
    }

    importReports(jsonData: string): boolean {
        try {
            const reports = JSON.parse(jsonData);
            if (Array.isArray(reports)) {
                this.saveReportsToStorage(reports);
                return true;
            }
            return false;
        } catch (error) {
            console.error('Error importing reports:', error);
            return false;
        }
    }

    private generateId(): string {
        return Date.now().toString(36) + Math.random().toString(36).substr(2);
    }

    /**
     * Clean up all related data for a report without deleting the report itself
     * This is useful for cleaning up generation state, checkpoints, etc.
     */
    cleanupReportData(id: string): void {
        try {
            // Stop any ongoing generation for this report
            reportGenerationService.stopGeneration(id);

            // Clear generation state
            reportGenerationService.clearGeneration(id);

            // Clear checkpoint data
            reportCheckpointService.clearCheckpoint(id);

            console.log(`Cleaned up data for report ${id}`);
        } catch (error) {
            console.error(`Error cleaning up data for report ${id}:`, error);
        }
    }

    /**
     * Check if a report has any related data (generation state, checkpoints, etc.)
     */
    hasRelatedData(id: string): boolean {
        const hasGenerationState = reportGenerationService.getGenerationState(id) !== null;
        const hasCheckpoint = reportCheckpointService.hasCheckpoint(id);
        return hasGenerationState || hasCheckpoint;
    }

    /**
     * Get a summary of what data will be cleaned up when deleting a report
     */
    getCleanupSummary(id: string): {
        hasGenerationState: boolean;
        hasCheckpoint: boolean;
        isGenerating: boolean;
        checkpointStatus?: string;
    } {
        const generationState = reportGenerationService.getGenerationState(id);
        const checkpoint = reportCheckpointService.getCheckpoint(id);

        return {
            hasGenerationState: generationState !== null,
            hasCheckpoint: checkpoint !== null,
            isGenerating: reportGenerationService.isGenerating(id),
            checkpointStatus: checkpoint?.status
        };
    }

    /**
     * Clean up orphaned data (data for reports that no longer exist)
     */
    cleanupOrphanedData(): number {
        const reports = this.getAllReports();
        const reportIds = new Set(reports.map(r => r.id));

        let cleanedCount = 0;

        // Clean up orphaned generation states
        const activeGenerations = reportGenerationService.getActiveGenerations();
        activeGenerations.forEach((state, reportId) => {
            if (!reportIds.has(reportId)) {
                reportGenerationService.clearGeneration(reportId);
                cleanedCount++;
            }
        });

        // Clean up orphaned checkpoints
        const allCheckpoints = reportCheckpointService.getAllCheckpoints();
        allCheckpoints.forEach(checkpoint => {
            if (!reportIds.has(checkpoint.reportId)) {
                reportCheckpointService.clearCheckpoint(checkpoint.reportId);
                cleanedCount++;
            }
        });

        if (cleanedCount > 0) {
            console.log(`Cleaned up ${cleanedCount} orphaned data entries`);
        }

        return cleanedCount;
    }
}

export const reportService = new ReportService();
*/
