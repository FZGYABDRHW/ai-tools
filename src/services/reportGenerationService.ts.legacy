// ============================================================================
// LEGACY REPORT GENERATION SERVICE - COMMENTED OUT DURING EFFECT-TS MIGRATION
// ============================================================================
// This service has been replaced by the new Effect-TS implementation
// See: src/services/effects/ for the new implementation
// ============================================================================

/*
import { buildServiceInitializer } from '../serviceInit';
import { buildReport } from '../reportBuilder';
import builder from '../builder';
import { reportService } from './reportService';
import { reportLogService } from './reportLogService';
import { reportCheckpointService } from './reportCheckpointService';
import { TaskListParameters } from './parameterExtractionService';

export type GenerationStatus = 'preparing' | 'in_progress' | 'paused' | 'completed' | 'failed' | 'ready';

export interface ReportGenerationState {
    reportId: string;
    status: GenerationStatus;
    progress: {
        processed: number;
        total: number;
    } | null;
    tableData: {
        columns: string[];
        results: Array<Record<string, unknown>>;
        csv: string;
    } | null;
    startTime: number;
    abortController: AbortController | null;
    errorMessage?: string;
    parameters?: TaskListParameters;
    extractedParameters?: {
        parameters: TaskListParameters;
        humanReadable: string[];
    };
}

interface GenerationCallbacks {
    onProgress?: (progress: any) => void;
    onComplete?: (result: any) => void;
    onError?: (error: any) => void;
}

class ReportGenerationService {
    private readonly STORAGE_KEY = 'wowworks_report_generations';
    private activeGenerations: Map<string, ReportGenerationState> = new Map();
    private generationCallbacks: Map<string, GenerationCallbacks> = new Map();

    constructor() {
        this.loadActiveGenerations();
    }

    private getStorageKey(): string {
        return this.STORAGE_KEY;
    }

    private loadActiveGenerations(): void {
        try {
            const stored = localStorage.getItem(this.getStorageKey());
            if (stored) {
                const generations = JSON.parse(stored);
                // Note: We can't restore AbortController from storage, so we'll create new ones
                Object.entries(generations).forEach(([reportId, state]: [string, any]) => {
                    // Handle legacy data that might have isGenerating instead of status
                    const status = state.status || (state.isGenerating ? 'in_progress' : 'completed');

                    this.activeGenerations.set(reportId, {
                        ...state,
                        status,
                        abortController: null // Will be recreated when needed
                    });
                });
            }
        } catch (error) {
            console.error('Error loading active generations:', error);
        }
    }

    private saveActiveGenerations(): void {
        try {
            const generations: Record<string, Omit<ReportGenerationState, 'abortController'>> = {};
            this.activeGenerations.forEach((state, reportId) => {
                generations[reportId] = {
                    reportId: state.reportId,
                    status: state.status,
                    progress: state.progress,
                    tableData: state.tableData,
                    startTime: state.startTime,
                    errorMessage: state.errorMessage,
                    parameters: state.parameters,
                    extractedParameters: state.extractedParameters
                };
            });
            localStorage.setItem(this.getStorageKey(), JSON.stringify(generations));
        } catch (error) {
            console.error('Error saving active generations:', error);
        }
    }

    private async saveGenerationStateToFileSystem(reportId: string, state: Omit<ReportGenerationState, 'abortController'>): Promise<boolean> {
        try {
            if ((window.electronAPI as any)?.fileSystem?.saveGenerationState) {
                return await (window.electronAPI as any).fileSystem.saveGenerationState(reportId, state);
            }
            return false;
        } catch (error) {
            console.error('Error saving generation state to file system:', error);
            return false;
        }
    }

    getActiveGenerations(): Map<string, ReportGenerationState> {
        return this.activeGenerations;
    }

    getGenerationState(reportId: string): ReportGenerationState | null {
        return this.activeGenerations.get(reportId) || null;
    }

    setCallbacks(reportId: string, callbacks: GenerationCallbacks): void {
        this.generationCallbacks.set(reportId, callbacks);
    }

    getCallbacks(reportId: string): GenerationCallbacks | null {
        return this.generationCallbacks.get(reportId) || null;
    }

    clearCallbacks(reportId: string): void {
        this.generationCallbacks.delete(reportId);
    }

    isGenerating(reportId: string): boolean {
        const state = this.activeGenerations.get(reportId);
        return state?.status === 'preparing' || state?.status === 'in_progress';
    }

    getGenerationStatus(reportId: string): GenerationStatus | null {
        const state = this.activeGenerations.get(reportId);
        return state?.status || null;
    }

    async updateGenerationStatus(reportId: string, status: GenerationStatus, errorMessage?: string): Promise<void> {
        const state = this.activeGenerations.get(reportId);
        if (state) {
            state.status = status;
            if (errorMessage) {
                state.errorMessage = errorMessage;
            }
            this.activeGenerations.set(reportId, state);

            // Save to file system first
            const stateToSave = {
                reportId: state.reportId,
                status: state.status,
                progress: state.progress,
                tableData: state.tableData,
                startTime: state.startTime,
                errorMessage: state.errorMessage,
                parameters: state.parameters,
                extractedParameters: state.extractedParameters
            };

            const fileSystemSaved = await this.saveGenerationStateToFileSystem(reportId, stateToSave);
            if (fileSystemSaved) {
                console.log(`✅ Updated generation status in file system for ${reportId}: ${status}`);
            } else {
                console.warn(`⚠️ Failed to save generation status to file system, falling back to localStorage: ${reportId}`);
            }

            // Also save to localStorage for immediate UI updates
            this.saveActiveGenerations();
            console.log(`Updated generation status for ${reportId}: ${status}`);
        }
    }

    async resetToReady(reportId: string): Promise<boolean> {
        // Always attempt to stop/clear current generation, checkpoints, and saved data
        try {
            const state = this.activeGenerations.get(reportId);

            // If something is running, attempt to stop and mark paused first
            if (state?.status === 'in_progress') {
                await this.stopGeneration(reportId);
            }

            // Clear generation state
            await this.clearGeneration(reportId);

            // Clear checkpoint data
            await reportCheckpointService.clearCheckpoint(reportId);

            // Clear saved report data (table results and extracted params)
            await reportService.clearReportData(reportId);

            console.log(`Reset report ${reportId} to ready state - cleared all data (prev status: ${state?.status || 'unknown'})`);
            return true;
        } catch (error) {
            console.error(`Failed to reset report ${reportId} to ready state:`, error);
            return false;
        }
    }

    setToPaused(reportId: string): boolean {
        const state = this.activeGenerations.get(reportId);
        if (state && (state.status === 'preparing' || state.status === 'in_progress' || state.status === 'failed')) {
            this.updateGenerationStatus(reportId, 'paused');
            return true;
        }
        return false;
    }

    setToCompleted(reportId: string): boolean {
        const state = this.activeGenerations.get(reportId);
        if (state && (state.status === 'preparing' || state.status === 'in_progress' || state.status === 'paused')) {
            this.updateGenerationStatus(reportId, 'completed');
            return true;
        }
        return false;
    }

    async rerunFromCompleted(reportId: string): Promise<boolean> {
        // Validate that the report exists
        const report = reportService.getReportById(reportId);
        if (!report) {
            console.error(`Report ${reportId} not found for rerun`);
            return false;
        }

        const state = this.activeGenerations.get(reportId);
        if (state && state.status === 'completed') {
            // Clear the completed state to allow new generation
            await this.clearGeneration(reportId);
            // Clear all report data (table data, extracted parameters) to ensure fresh start
            await reportService.clearReportData(reportId);
            console.log(`Report ${reportId} ready for rerun - cleared generation state and all report data`);
            return true;
        }
        return false;
    }

    async restartFromFailed(reportId: string): Promise<boolean> {
        // Validate that the report exists
        const report = reportService.getReportById(reportId);
        if (!report) {
            console.error(`Report ${reportId} not found for restart`);
            return false;
        }

        const state = this.activeGenerations.get(reportId);
        if (state && state.status === 'failed') {
            // Clear the failed state to allow new generation
            await this.clearGeneration(reportId);
            // Clear all report data (table data, extracted parameters) to ensure fresh start
            await reportService.clearReportData(reportId);
            console.log(`Report ${reportId} ready for restart from failed state - cleared generation state and all report data`);
            return true;
        }
        return false;
    }

    async startGeneration(
        reportId: string,
        reportText: string,
        authToken: string,
        selectedServer: string = 'EU',
        onProgress?: (progress: any) => void,
        onComplete?: (result: any) => void,
        onError?: (error: any) => void,
        startOffset: number = 0,
        parameters?: TaskListParameters
    ): Promise<void> {
        // Store callbacks for this generation
        this.setCallbacks(reportId, { onProgress, onComplete, onError });
        // Create or get report
        let report = reportService.getReportById(reportId);
        if (!report) {
            report = await reportService.createReport({
                name: 'Custom Operational Report',
                prompt: reportText
            });
        }

        const abortController = new AbortController();
        const startTime = Date.now();

        // Check if we're resuming and preserve existing data
        const existingState = this.activeGenerations.get(reportId);
        let existingTableData = existingState?.tableData;
        const existingProgress = existingState?.progress;

        // Load any existing checkpoint table data even if startOffset is 0 (small resumes)
        const existingCheckpoint = reportCheckpointService.getCheckpoint(reportId);
        if (existingCheckpoint?.tableData) {
            existingTableData = existingCheckpoint.tableData;
            console.log(`Restoring table data from checkpoint: ${existingTableData.results.length} results (offset ${startOffset})`);
        }

        const generationState: ReportGenerationState = {
            reportId,
            status: 'preparing',
            progress: existingProgress || null,
            tableData: existingTableData || null,
            startTime,
            abortController,
            parameters
        };

        this.activeGenerations.set(reportId, generationState);
        this.saveActiveGenerations();

        // Create checkpoint only if none exists (handles resume case even when offset is 0)
        const hasExistingCheckpoint = reportCheckpointService.hasCheckpoint(reportId);
        if (!hasExistingCheckpoint) {
            await reportCheckpointService.createCheckpoint(reportId, reportText, 0, startTime, startOffset);
        } else {
            console.log(`Resuming generation - using existing checkpoint with offset ${startOffset}`);
        }

        try {
            const si = buildServiceInitializer(authToken, selectedServer as any);

            // Start the build process and get parameters immediately
            const result = await buildReport(
                reportText,
                si,
                (taskId) => builder(taskId, authToken, selectedServer),
                async (progress) => {
                    // Merge new progress with existing data if resuming
                    let mergedProgress = progress;
                    if (existingTableData) {
                        // Merge existing results with new results
                        mergedProgress = {
                            ...progress,
                            results: [...existingTableData.results, ...progress.results]
                        };
                        console.log(`Merged progress: ${existingTableData.results.length} existing + ${progress.results.length} new = ${mergedProgress.results.length} total`);
                    } else {
                        // For new generation, use progress as is
                        mergedProgress = progress;
                    }

                    // Update state
                    generationState.tableData = mergedProgress;
                    generationState.progress = {
                        processed: mergedProgress.results.length,
                        total: mergedProgress.results.length
                    };
                    this.saveActiveGenerations();

                    // Save to report service
                    await reportService.saveReportData(reportId, mergedProgress);

                    // Update checkpoint with the total number of tasks processed
                    const totalTasksProcessed = mergedProgress.results.length;
                    await reportCheckpointService.updateCheckpoint(
                        reportId,
                        `task_${totalTasksProcessed}`,
                        mergedProgress,
                        totalTasksProcessed,
                        mergedProgress
                    );

                    // Call progress callback
                    const callbacks = this.getCallbacks(reportId);
                    callbacks?.onProgress?.(mergedProgress);
                },
                (extractedParams) => {
                    // Store extracted parameters immediately for UI display
                    generationState.extractedParameters = extractedParams;
                    this.saveActiveGenerations();
                    // Also persist to file system right away so a pause or app crash preserves them
                    void this.updateGenerationStatus(reportId, 'in_progress');
                    console.log('Parameters extracted and stored immediately:', extractedParams);
                },
                abortController.signal,
                startOffset,
                parameters,
                // Reuse existing columns if available to avoid re-fetching schema
                existingTableData?.columns || report?.tableData?.columns,
                // Status update callback
                async (status) => {
                    await this.updateGenerationStatus(reportId, status);
                }
            );

            // Final save - merge with existing data if resuming
            let finalResult = result;
            if (existingTableData) {
                finalResult = {
                    ...result,
                    results: [...existingTableData.results, ...result.results]
                };
                console.log(`Final result merged: ${existingTableData.results.length} existing + ${result.results.length} new = ${finalResult.results.length} total`);
            }

            generationState.tableData = finalResult;

            // Store extracted parameters if available
            if (result.extractedParameters) {
                generationState.extractedParameters = result.extractedParameters;
                console.log('Stored extracted parameters:', result.extractedParameters);
            }

            await this.updateGenerationStatus(reportId, 'completed');

            // Save to report service with extracted parameters
            await reportService.saveReportData(reportId, finalResult, result.extractedParameters);

            // Create report log with extracted parameters
            await reportLogService.createFromReportGeneration(
                reportId,
                report.name,
                reportText,
                finalResult,
                finalResult.results.length,
                finalResult.results.length,
                startTime,
                'completed',
                undefined,
                result.extractedParameters
            );

            // Mark checkpoint as completed
            await reportCheckpointService.markCompleted(reportId);

            const callbacks = this.getCallbacks(reportId);
            callbacks?.onComplete?.(finalResult);
            this.clearCallbacks(reportId);
        } catch (error: any) {
            if (error.message !== 'Aborted') {
                // Create report log for failed generation
                const failedData = generationState.tableData || { columns: [], results: [], csv: '' };
                await reportLogService.createFromReportGeneration(
                    reportId,
                    report.name,
                    reportText,
                    failedData,
                    generationState.progress?.processed || 0,
                    generationState.progress?.total || 0,
                    startTime,
                    'failed',
                    error.message
                );

                // Mark checkpoint as failed
                await reportCheckpointService.markFailed(reportId, error.message);

                // Update generation status to failed
                await this.updateGenerationStatus(reportId, 'failed', error.message);
            } else {
                // Mark checkpoint as paused for aborted generations
                await reportCheckpointService.markPaused(reportId);

                // Update generation status to paused
                await this.updateGenerationStatus(reportId, 'paused');
            }

            const callbacks = this.getCallbacks(reportId);
            callbacks?.onError?.(error);
            this.clearCallbacks(reportId);
        }
    }

    async stopGeneration(reportId: string): Promise<boolean> {
        const state = this.activeGenerations.get(reportId);
        if (state?.abortController) {
            state.abortController.abort();

            // Mark checkpoint as paused when manually stopped
            await reportCheckpointService.markPaused(reportId);

            // Update generation status to paused
            await this.updateGenerationStatus(reportId, 'paused');

            return true;
        }
        // Fallback: if we have a state but no abort controller yet (very early preparation), still mark as paused
        if (state) {
            await reportCheckpointService.markPaused(reportId);
            await this.updateGenerationStatus(reportId, 'paused');
            return true;
        }
        return false;
    }

    async clearGeneration(reportId: string): Promise<void> {
        // Delete from file system first
        try {
            if ((window.electronAPI as any)?.fileSystem?.deleteGenerationState) {
                const fileSystemDeleted = await (window.electronAPI as any).fileSystem.deleteGenerationState(reportId);
                if (fileSystemDeleted) {
                    console.log(`✅ Deleted generation state from file system: ${reportId}`);
                } else {
                    console.warn(`⚠️ Failed to delete generation state from file system: ${reportId}`);
                }
            }
        } catch (error) {
            console.error(`Error deleting generation state from file system: ${reportId}:`, error);
        }

        // Also remove from localStorage
        this.activeGenerations.delete(reportId);
        this.saveActiveGenerations();
    }

    clearExtractedParameters(reportId: string): void {
        const state = this.activeGenerations.get(reportId);
        if (state) {
            state.extractedParameters = undefined;
            this.saveActiveGenerations();
        }
    }

    /**
     * Clear all data for a report (generation state, checkpoints, report data)
     * This ensures a completely fresh start
     */
    clearAllReportData(reportId: string): void {
        // Clear generation state
        this.clearGeneration(reportId);

        // Clear checkpoint data
        reportCheckpointService.clearCheckpoint(reportId);

        // Clear report table data
        reportService.clearReportData(reportId);

        console.log(`Cleared all data for report ${reportId}`);
    }

    clearAllGenerations(): void {
        this.activeGenerations.clear();
        this.saveActiveGenerations();
    }

    reconnectToGeneration(reportId: string, callbacks: GenerationCallbacks): boolean {
        const state = this.getGenerationState(reportId);
        if (state && (state.status === 'preparing' || state.status === 'in_progress')) {
            this.setCallbacks(reportId, callbacks);
            // Trigger immediate callback with current state
            if (state.tableData) {
                callbacks.onProgress?.(state.tableData);
            }
            return true;
        }
        return false;
    }

    async resumeGeneration(
        reportId: string,
        authToken: string,
        selectedServer: string = 'EU',
        onProgress?: (progress: any) => void,
        onComplete?: (result: any) => void,
        onError?: (error: any) => void
    ): Promise<void> {
        console.log(`Attempting to resume generation for report ${reportId}`);
        const checkpoint = reportCheckpointService.getCheckpoint(reportId);
        console.log('Checkpoint found:', checkpoint);

        if (!checkpoint) {
            console.error('No checkpoint found for this report');
            throw new Error('No checkpoint found for this report');
        }

        console.log(`Checkpoint status: ${checkpoint.status}`);
        if (checkpoint.status !== 'paused' && checkpoint.status !== 'in_progress') {
            console.error(`Checkpoint status is ${checkpoint.status}, cannot resume`);
            throw new Error(`Checkpoint status is ${checkpoint.status}, cannot resume`);
        }

        // Resume the checkpoint
        console.log('Attempting to resume checkpoint...');
        const resumedCheckpoint = await reportCheckpointService.resumeCheckpoint(reportId);
        if (!resumedCheckpoint) {
            console.error('Failed to resume checkpoint');
            throw new Error('Failed to resume checkpoint');
        }
        console.log('Checkpoint resumed successfully:', resumedCheckpoint);

        // Calculate the correct offset for resuming
        const startOffset = reportCheckpointService.getResumeOffset(reportId);
        console.log(`Resuming report ${reportId} from offset ${startOffset} with ${checkpoint.currentTaskIndex} completed tasks`);

        // Resolve parameters prepared during the previous session (prefer explicit saved ones)
        const existingState = this.getGenerationState(reportId);
        const persistedReport = reportService.getReportById(reportId);
        const resumedParameters = existingState?.parameters
            || existingState?.extractedParameters?.parameters
            || persistedReport?.extractedParameters?.parameters
            || undefined;

        // Start generation from where it left off
        console.log('Starting generation with startOffset:', startOffset);
        await this.startGeneration(
            reportId,
            checkpoint.prompt,
            authToken,
            selectedServer,
            onProgress,
            onComplete,
            onError,
            startOffset,
            resumedParameters
        );
    }
}

export const reportGenerationService = new ReportGenerationService();
*/
